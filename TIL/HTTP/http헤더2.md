# 2021년 10월 10일 (일)

## 캐시와 조건부 요청

### 만약에 캐시가 없다면 ? -> 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다. 하지만 이렇게 되면 인터넷 네트워크는 매우 느리고 비싸기 때문에 브라우저 로딩 속도가 느려지고, 느린 사용자 경혐을 유발시킨다.

### 캐시를 적용 한다면 ? -> 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다. 그러므로 비싼 네트워크 사용량을 줄일 수 있고, 브라우저 로딩 속도가 빨라져 빠른 사용자 경험을 제공할 수 있다.

### 캐시 유효 시간이 존재하는데 만약 이 캐시 시간이 초과하게 되면, 서버를 통해 다시 데이터를 조회하고 캐시를 갱신한다. -> 이 때 다시 네트워크 다운로드가 발생한다.

### 캐시 유효시간이 초과해서 서버에 다시 요청하면 두가지 상황이 나타난다.

#### 1. 서버에서 기존 데이터를 변경하여 바뀐 상태임

#### 2. 서버에서 기존 데이터를 변경하지 않아 그대로임

### 캐시 만료후에도 서버에서 데이터를 변경하지 않았다면, 저장해 두었던 캐시를 재사용할 수 있다. 단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다. -> 데이터를 처음 서버에 요청할 때, 검증 헤더에 Last-Modified를 추가하여 서버에서 클라이언트에 전달 해주고, 클라이언트는 캐시 만료 뒤 재요청을 하는 경우, 서버에 If-Modified-Since 값을 헤더에 포함하여 전달하여 서버의 값(Last-Modified)과 비교한 뒤 값이 같다면 Http 바디는 제외하고 Http 헤더만 서버에서 클라이언트로 전송을 한다.

#### 이렇게 되면, 클라이언트는 다시 저장되었던 캐시값을 그대로 사용할 수 있다.

### 검증 헤더와 조건부 요청 정리

#### 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면 304 Not Modified + 헤더 메타 정보만 응답(메세지 바디 제외)

#### 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신 -> 클라이언트는 캐시에 저장되어 있는 데이터를 재활용 한다.

#### 결과적으로, 네트워크 다운로드는 발생하지만 용량이 적은 헤더 정보만 다운로드 하므로 매우 실용적인 해결책이다.

### 만약 If-Modified-Since값 이후에 데이터가 수정되었다면 ? -> 서버에서 응답의 결과 200 ok로 모든 데이터를 전송한다. (메세지 바디 포함)

## 캐시 제어 헤더(Cache-Control, Pragma, Expires)

### Cache-Control의 값이 max-age로 설정되어 있다면, 캐시 유효 시간을 의미 한다. no-cache로 설정되어 있다면, 데이터는 캐시해도 되지만 항상 서버에 조건부 요청을 하여(If-Modified-Since 와 같이) 검증을 한 뒤 사용하여야 한다. no-store로 설정되어 있다면, 데이터에 민감한 정보가 있으므로 저장하면 안됨을 의미한다.

### Pragma는 거의 사용하지 않는다.

### Expires -> 캐시 만료일을 지정한다. ex) expires: Mon, 01 Jan 1990 00:00:00 GMT / 캐시 만료일을 정확한 날짜로 지정한다. 현재는 더 유연한 Cache-Control: max-age를 권장한다.
