# 자바스트립트 메모리 관리

### 메모리 생명주기

- 메모리 할당(변수, 함수, 객체 등을 만들때 메모리를 할당한다.) -> 메모리 사용(변수를 읽거나 쓸때 할당된 메모리를 사용한다.) -> 메모리 해제(더 이상 필요가 없어지면 메모리에서 해제한다.)

### 메모리 할당

- 메모리는 힙과 스택에 할당되는데, 원시값의 경우 스택에 할당되고 고정된 메모리를 할당하게 된다. 고정된 메모리에 할당하기 때문에 정적 메모리 할당이라고도 한다.
- 고정된 양의 메모리를 할당하기 때문에 원시 값들의 크기에 제한이 있다. ex) boolean의 경우 1비트 number의 경우 64비트
- 참조 값의 경우 힙에 저장된다. 참조 값을 필요한 만큼 많은 메모리를 할당하기 때문에 동적 메모리 할당이라고도 한다.
- 주소 값의 경우 스택에 저장된다.

### 가비지 컬렉션

- 가비지 컬렉션은 자바스크립트 엔진이 메모리를 해제하는 방식이다. 더 이상 필요가 없어지면 메모리에서 해제한다.
- 메모리 해제 방식
  - Reference Counting : 자신을 참조하는 객체의 수를 센다. 만약, 참조가 되지 않는 객체가 있다면 해당 객체를 수거한다. 하지만 이러한 순환 참조 방식에는 메모리 누수를 일으키는 문제가 있어 Mark and Sweep 방식이 도입되었다.
  - Mark and Sweep: 루트에서 도달 가능한 객체를 표시한다. 도달 불가능한 객체를 수거 대상으로 확인하고 해제한다.

### V8 가비지 컬렉션

- 자바스크립트 엔진은 새로운 객체를 할당할 때, new space 안에 있는 semi space에 객체를 할당 시키는데 메모리 영역이 모두 할당되면 Minor GC가 발생한다. 여기서 살아남은 객체는 다른 s emi space로 이동하게 된다. 두번째 semi space의 메모리도 모두 할당되면 두번재 Minor GC가 발생하는데 여기서 살아남은 객체들은 old space로 이동하게 된다.
- old space에서는 동적으로 계산된 결과에 따라 공간이 부족하다고 판단될 때 Major GC가 발생한다. (new space는 메모리가 가득찼을 때 가비지 컬렉션이 발생한다.)
- 가비지 컬렉션은 메인 스레드에서 발생하기 때문에 자바스크립트가 실행되지 않는 현상이 있다. 이 현상을 stop-the-world라고 한다.
- 이러한 stop-the-world 현상을 해결하기 위해 V8 엔지니어들은 여러가지 방식을 도입하였다.
- Parallel: 메인 스레드 혼자 하던 일을 헬퍼 스레드들과 균등하게 나누어 일을 하게 한다. -> 스레드 간의 동기화를 처리해야 해서 오버헤드는 생기지만 stop-the-world 시간이 크게 감소한다.
- Incremental: 가비지 컬렉션의 작업을 나누어 처리한다. -> 메인 스레드에서 가비지 컬렉션에 소요하는 시간이 분산되어, 좋은 UX를 제공할 수 있다.
- concurrent: 메인 스레드는 더 이상 가비지 컬렉션을 하지 않고, 헬퍼 스레드들이 수행한다. -> 기술적으로 구현하기는 어렵지만, 메인 스레드의 stop-the-world 시간이 전혀 없다는 큰 장점이 있다.
- idle-time GC: 애니메이션 프레임 렌더링 작업이 16ms보다 빨리 끝나면, 다음 프레임 작업 전까지 가비지 컬렉션을 유발한다.
